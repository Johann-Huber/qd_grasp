
import pdb

import os
import numpy as np
from pathlib import Path

from gym import Env
import pybullet_data
from pybullet_utils.bullet_client import BulletClient
import pybullet as p

import utils.constants as consts
import gym_envs.envs.src.env_constants as env_consts

from gym_envs.envs.src.bullet_simulation.simulation_rendering import SimulationRendering
from gym_envs.envs.src.bullet_simulation.simulation_engine import SimulationEngine
from utils.common_tools import MustBeOverloadedError


class RobotGrasping(Env):

    def __init_subclass__(cls, *args, **kwargs):
        super().__init_subclass__(*args, **kwargs)

    def __init__(
            self,
            run_name=None,
            display=consts.BULLET_DEFAULT_DISPLAY_FLG,
            table_label=env_consts.TableLabel.STANDARD_TABLE,
            **kwargs
            ):
        self.bullet_client = None  # bullet physics client
        self.physics_client_id = None  # bullet physics client id
        self.sim_render = None  # manage simulation rendering
        self.sim_engine = None  # manage simulation engine
        self.initial_state = None  # robot initial state (used in robot_env)
        self.n_dof_arm = None  # number of dof associated to the manipulator: initialized in subclasses

        self._init_attributes(run_name, display, table_label, kwargs)

    @property
    def display(self):
        return self.sim_render.display

    @display.setter
    def display(self, val):
        self.sim_render.display = val

    @property
    def robot_id(self):
        return self.sim_engine.robot_id

    @property
    def obj_id(self):
        return self.sim_engine.obj_id

    @property
    def init_state_p_file_root(self):
        return self.sim_engine.init_state_p_file_root

    @property
    def joint_ids(self):
        return self.sim_engine.joint_ids

    @property
    def info(self):
        return self.sim_engine.info

    @property
    def n_actions(self):
        return self.sim_engine.n_actions

    @property
    def end_effector_id(self):
        return self.sim_engine.end_effector_id

    def _init_attributes(self, run_name, display, table_label, kwargs):

        self._init_bullet_physics_client(display=display)

        sim_engine_kwargs = {
            'bullet_client': self.bullet_client,
            'table_label': table_label,
            'n_dof_arm': self.n_dof_arm,
            **kwargs
        }

        self.sim_engine = SimulationEngine(**sim_engine_kwargs)
        self._reset_robot()
        self.sim_engine.init_local_sim_save(bullet_client=self.bullet_client)

        self._init_rendering(
            display=display, table_label=table_label
        )

    def _init_joint_ids(self, joint_ids):
        assert joint_ids is not None, 'joint_ids cannot be None'
        return np.array(joint_ids, dtype=int)

    def _init_rendering(self, display, table_label):
        self.sim_render = SimulationRendering(bullet_client=self.bullet_client, display=display, table_label=table_label)

    def _init_bullet_physics_client(self, display):
        self.bullet_client = BulletClient(connection_mode=p.GUI if display else p.DIRECT)
        self.physics_client_id = self.bullet_client._client
        self.bullet_client.setAdditionalSearchPath(pybullet_data.getDataPath())  # add link to urdf files

    def step(self, action):
        assert action is not None, 'invalid input action'

        apply_action_kwargs = {
            'bullet_client': self.bullet_client,
            'action': action,
        }
        observation, reward, done, info = self.sim_engine.apply_action_to_sim(**apply_action_kwargs)

        return observation, reward, done, info

    def get_state(self):
        return self.sim_engine.get_state(bullet_client=self.bullet_client)

    def _load_state_from_local_save(self, force_state_load):
        if force_state_load:
            #  in some cases, a init_state_bullet file has not been generated for each worker (e.g. plot_trajs)
            #  in this case, we rely on the file generated by the main thread. In this case, bullet simulation is not
            # deterministc.

            file2load = self.init_state_p_file_root
        else:
            local_pid_str = str(os.getpid())
            init_state_p_local_pid_file = self.init_state_p_file_root + '_' + local_pid_str
            file2load = init_state_p_local_pid_file

        self.bullet_client.restoreState(fileName=file2load)

    def reset(
            self,
            skip_state_reload=False,
            force_state_load=False,
            obj_init_state_offset=None,
            init_rand_orient_euler=None,
            do_noise_joints_pos=False,
            do_noise_dynamics=False,
            **kwargs
    ):
        observation = self.sim_engine.reset(do_noise_joints_states=do_noise_joints_pos)

        assert self.init_state_p_file_root, 'bullet tmp file not properly set'

        if skip_state_reload:
            self._reset_robot()
        else:
            self._load_state_from_local_save(force_state_load=force_state_load)

        if obj_init_state_offset is not None:
            self._reset_object_pose(obj_init_state_offset=obj_init_state_offset)

        if do_noise_dynamics:
            self._perturbate_dynamics()

        return observation

    def close(self):
        is_bullet_client_on = self.physics_client_id >= 0
        if is_bullet_client_on:
            self.bullet_client.disconnect()
            self.physics_client_id = -1

    def _reset_object_pose(self, obj_init_state_offset):
        self.sim_engine.reset_object_pose(bullet_client=self.bullet_client, obj_init_state_offset=obj_init_state_offset)

    def _perturbate_dynamics(self):
        self.sim_engine.perturbate_dynamics(bullet_client=self.bullet_client)

    def get_joint_state(self, position=True, normalized=True):
        return self.sim_engine.get_joint_state(
            bullet_client=self.bullet_client, position=position, normalized=normalized
        )

    def get_joints_poses_from_ik(self, pos, or_pry, normalized=False):
        kwargs = {
            'bullet_client': self.bullet_client,
            'pos': pos,
            'or_pry': or_pry,
            'normalized': normalized,
            'arm_controllable_joint_ids': self._get_arm_controllable_joint_ids(),
            'rest_poses': self._get_rest_poses(),
            'controllable_joint_ids': self._get_controllable_joint_ids(),
        }
        return self.sim_engine.get_joints_poses_from_ik(**kwargs)

    def _load_model(self):
        raise MustBeOverloadedError()

    def _get_rest_poses(self):
        raise MustBeOverloadedError()

    def _is_gripper_closed(self, action):
        raise MustBeOverloadedError()

    def _get_gripper_controllable_joint_ids(self):
        raise MustBeOverloadedError()

    def _reset_robot(self):
        raise MustBeOverloadedError()

    def _get_arm_controllable_joint_ids(self):
        raise MustBeOverloadedError

    def _get_controllable_joint_ids(self):
        raise MustBeOverloadedError

    def reset_camera_pose_for_specific_table(self, table_label):
        self.sim_render.reset_camera_pose_for_specific_table(bullet_client=self.bullet_client, table_label=table_label)

